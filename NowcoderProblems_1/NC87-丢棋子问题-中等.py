# -*- coding:utf-8 -*-
'''
https://www.nowcoder.com/practice/d1418aaa147a4cb394c3c3efc4302266?tpId=117&&tqId=37844&&companyId=665&rp=1&ru=/company/home/code/665&qru=/ta/job-code-high/question-ranking

题目描述

一座大楼有层，地面算作第0层，最高的一层为第 层。已知棋子从第0层掉落肯定不会摔碎，从第层掉落可能会摔碎，也可能不会摔碎。给定整数作为楼层数，再给定整数作为棋子数，返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最小次数。一次只能扔一个棋子。

示例1
输入
复制
10,1
返回值
复制
10
说明
因为只有1棵棋子，所以不得不从第1层开始一直试到第10层，在最差的情况下，即第10层是不会摔坏的最高层，最少也要扔10次
示例2
输入
复制
3,2
返回值
复制
2
说明
先在2层扔1棵棋子，如果碎了，试第1层，如果没碎，试第3层
示例3
输入
复制
105,2
返回值
复制
14
说明
第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13层
若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26层
若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试28~38层
若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49层
若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试51~59层
若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试61~68层
若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试70~76层
若没碎，第一个棋子继续在84层扔，碎了则用仅存的一个棋子试78~83层
若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试85~89层
若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试91~94层
若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试96~98层
若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101层
若没碎，第一个棋子继续在104层扔，碎了则用仅存的一个棋子试103层
若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果
备注:
0≤N,K≤10^60≤N,K≤10
6

https://www.cnblogs.com/willwuss/p/12256475.html
以下的实现方式是参考的第五种方法, 也就是最优解.
以下的实现, 其实优化了空间. 也就是把解析里面的map矩阵缩减成了一个一维数组.
为什么dp数组只有k个值呢? k是棋子的数量. dp其实相当于参考文章里面用到的那个表格map的一列.
然后代码里面的i其实相当于是map表的列数, j才是map表的行数. i的那个循环相当于为map增加新的列, j的循环则是更新本列.
(i+1)就代表着扔的次数. 每多扔一次, 增加map的一列.
'''
import math
class Solution:
    def solve(self , n , k ):
        # write code here
        if n <= 1 or k==1:
            return n
        bstimes = int(math.log2(n))+1
        if k > bstimes:
            return bstimes
        dp = [1 for i in range(k)]
        for i in range(1, n + 1):
            pre = dp[0]
            dp[0] += 1
            for j in range(1, k):
                tmp = dp[j]
                dp[j] += pre + 1
                pre = tmp
                if dp[j] >= n:
                    return i+1

print(
    Solution().solve(105, 2)
)